# Indexing with MinHash Bloom Trees

\chaptermark {MHBT}

## Abstract

## Introduction

### Hierarchical index

Searching for matches in large collection of datasets is not viable when hundreds of thousands of
them are available,
especially if they are partitioned and not all present at the same place.

Bloofi [@crainiceanu_bloofi:_2015] is a hierarchical index structure that
extends the Bloom Filter basic query to collections of Bloom Filters.
Instead of calculating the union of all Bloom Filters in the collection
(which would allow answering if an element is present in any of them)
it defines a tree structure where the original Bloom Filters are leaves,
and internal nodes are the union of all the Bloom Filters in their subtrees.
Searching is based on a breadth-first search,
with pruning when no matches are found at an internal level.
Bloofi can also be partitioned in a network,
with network nodes containing a subtree of the original tree and only being
accessed if the search requires it.

The Sequence Bloom Tree [@solomon_fast_2016] adapts Bloofi for genomic contexts,
rephrasing the problem as experiment discovery:
given a query sequence $Q$ and a threshold $\theta$,
which experiments contain at least $\theta$ of the original query $Q$?
Experiments are encoded in Bloom Filters containing the $k$-mer composition of transcriptomes,
and queries are transcripts.

Further developments focused on clustering similar datasets to prune search
early [@sun_allsome_2017] and developing more efficient representations for the
internal nodes [@solomon_improved_2017] [@harris_improved_2018] to use less
storage space and memory.

### Inverted index

<!--
- a map of hash -> list of dataset IDs
- differs from kraken: it collapses the list of dataset IDs to the LCA,

- Mantis is also an inverted index (hash -> color), where 'color' encodes
  a subset of the datasets
-->

## Results

### Efficient containment and similarity searches

#### Index construction and updating

resources (time, cpu, mem)
<!--

- sourmash indices benefit from more data. Inverted index

-->

#### Querying

<!--
COST (cost of single thread)
-->

### CAMI challenges

<!--

Intro: what is CAMI, what it provides:
- challenges provide gold standards (what is expected to be in the sample)
- standardized tools for profiling performance comparisons (OPAL)

-->

#### CAMI 1 (low, medium, high)

<!--
- Already published, but results are for older/outdated tools
- still a good benchmark (because gold standards are available)
- low and medium datasets have viruses, which are not in sourmash indices
-->

#### CAMI 2 mouse gut toy challenge

<!--
- new CAMI challenges, with short and long reads (pacbio)
- toy challenge is calibration: gold standard available
- CAMI provides results for other tools

CAMI 2 refseq database also doesn't have viruses...

- sourmash gather:
-->

## Discussion

### Limitations

<!--
Viruses (scaled minhash too small).
  mash screen solves this by going for sensitivity (at the cost of precision),
  possible solution: scaled+num hashes, but would only allow mash screen-like method


-->

### Future directions

<!--
- Better localization in SBT
- batch_insert for SBT, insert_one for Inverse Index
- Other indices
  * Fundamentally a scaled minhash is a subset of the k-mer composition of a
  dataset, so any index from https://www.biorxiv.org/content/10.1101/866756v1
  ("Data structures based on k-mers for querying large collections of sequencing datasets")
  can be used to scale.
  * since gather is defined over a collection of signatures,
- gather assigns hashes to best matches ("winner-takes-all"). Other approaches
  will be needed to disambiguate matches further
- sourmash is single threaded, but parallel queries are possible
-->

### Summary/Conclusion

## Methods

### Mathematical foundations

### Implementation

sourmash is implemented in

### Experiments
